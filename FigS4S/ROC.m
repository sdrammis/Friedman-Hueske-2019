classdef ROC < handle
    % ROC Object Class Summary of this class goes here
    %   Detailed explanation goes here

    properties (SetAccess = private)
        % Set @ Initialization
        TWDB
        NLearningSections
        NSessionSections
        TaskType

        % Derived @ Init from Class Method
        WTMice
        HDMice

        % Generated by obj.load()
        TDataSplit = NaN
        FDataSplit = NaN
        DDataSplit = NaN
        CDataSplit = NaN

        TDataUnsplit = NaN
        FDataUnsplit = NaN
        DDataUnsplit = NaN
        CDataUnsplit = NaN

        IgnoreSplit

        % Depend on TaskType; Set in Constructor
        Sessions
    end

    properties (GetAccess = private)
        TrialsPerPseudoSession = 20;
    end

    properties (Access = private)
        NTrainLearningSections = 3;  % DO NOT CHANGE
        NTrainSessionSections = 1;   % DO NOT CHANGE

        % Depend on TaskType; Set in Constructor
        Tone

        % CONSTANTS
        MiceTypes = {'WT', 'HD'};
        ValidTaskTypes = {'tt', '2tr'};

        Trainer = HMM_trainer;

        SavePath = 'Functions/ROC (JF, LR)/analysis/data/';
        VarsToSave = {'TDataSplit', 'FDataSplit', 'DDataSplit', 'CDataSplit',...
                        'TDataUnsplit', 'FDataUnsplit', 'DDataUnsplit', 'CDataUnsplit',...
                        'TWDB', 'WTMice', 'HDMice', 'TaskType', 'IgnoreSplit'}

        EstimatePath = 'Functions/ROC (JF, LR)/analysis/functions/HMM estimates/'
    end

    methods (Access = public)
        % CONSTRUCTOR
        function obj = ROC(twdb, n_learning_sections, n_session_sections, varargin)
            if nargin < 3
                error('Need TWDB, NLearning, and NSession');
            end

            obj.TWDB = twdb;

            obj.NLearningSections = n_learning_sections;
            obj.NSessionSections = n_session_sections;

            task_type_index = find(strcmp('TaskType', varargin), 1);
            if ~isempty(task_type_index)
                task_type = varargin{task_type_index + 1};
                if isempty(find(strcmp(obj.ValidTaskTypes, task_type), 1))
                    error('Invalid task type');
                end

                obj.TaskType = task_type;
            else
                obj.TaskType = 'tt';
            end

            switch obj.TaskType
                case 'tt'
                    obj.Tone = 1;
                case '2tr'
                    obj.Tone = 2;
            end

            obj.WTMice = ROC.get_mice('WT', obj.TaskType);
            obj.HDMice = ROC.get_mice('HD', obj.TaskType);
            obj.Sessions = lookup(obj.TWDB, 'taskType', '=', obj.TaskType);

            % Run Analysis
            obj.run(varargin{:});
        end

        % LIFECYCLE
        function save(obj, varargin)
            if nargin > 1
                path = varargin{1};
            else
                path = obj.SavePath;
            end

            filename = [path obj.default_filename()];
            save(filename, 'obj')
        end

        function load(obj, path)
            temp = load(path);

            disp('Found existing analysis in path. Attempting to load.');
            temp_obj = temp.obj;

            % Copy Properties
            for var =  obj.VarsToSave
                val = var{:};
                try   % may fail if property is read-only
                    obj.(val) = temp_obj.(val);
                catch
                    disp('Load failed. Running analysis from scratch.');
                    error('Failed to load');
                end
            end
        end

        function run(obj, varargin)
            ignore_index = find(strcmp('IgnoreSplit', varargin), 1);
            obj.IgnoreSplit = ~isempty(ignore_index);

            force_index = find(strcmp('ForceGenerate', varargin), 1);
            force_generate = ~isempty(force_index);

            path_index = find(strcmp('Path', varargin), 1);
            if ~isempty(path_index)
                path = varargin{path_index + 1};
            else
                path = obj.SavePath;
            end

            try
                % Try loading if already generated (and not force
                % generating)
                if ~force_generate
                    full_path = [path obj.default_filename()];
                    obj.load(full_path)
                else
                    error('Forced error')
                end
            catch
                warning(['ROC Data with LearningN = ' num2str(obj.NLearningSections) ', SessionN = ' num2str(obj.NSessionSections) ' and given TWDB does not exist. Running generate() to create it...']);
                obj.generate()
            end
        end

        % HELPERS
        function [mouseID] = get_mouse_id(obj, type, index)
            % function: Short description
            %
            % Extended description
            if strcmp(type, 'WT')
                mice = obj.WTMice;
            elseif strcmp(type, 'HD')
                mice = obj.HDMice;
            else
                error('Invalid mouse type. Only WT or HD')
            end

            mouseID = mice{index};
        end
    end

    methods (Access = private)
        % ANALYSIS
        function generate(obj)
            %GENERATE_ROC_DATA Summary of this function goes here
            %   Detailed explanation goes here

            obj.generate_helper(false);

            if obj.IgnoreSplit
                [obj.TDataSplit, obj.FDataSplit, obj.DDataSplit, obj.CDataSplit] = deal(NaN);
            else
                try
                    obj.generate_helper(true);
                catch
                    [obj.TDataSplit, obj.FDataSplit, obj.DDataSplit, obj.CDataSplit] = deal(NaN);
                end
            end
        end

        function generate_helper(obj, split)
            %  We ignore NSessionSections (i.e. set to 1) if splitting
            %   (b/c ALL sections ENGAGED, no need to split within session)
            %   However, we keep the object property the same for non-split analysis
            if split
                TempSessionSections = 1;
            else
                TempSessionSections = obj.NSessionSections;
            end

            t_data = containers.Map;
            f_data = containers.Map;
            d_data = containers.Map;
            c_data = containers.Map;

            % Compute all TPR, FPR, D, C values for all mice types...
            for elt = obj.MiceTypes
                mouse_type = elt{:};
                [mice, mice_n] = ROC.get_mice(mouse_type, obj.TaskType);

                raw_t_local = cell(mice_n, obj.NLearningSections, TempSessionSections);
                raw_f_local = cell(mice_n, obj.NLearningSections, TempSessionSections);
                raw_d_local = cell(mice_n, obj.NLearningSections, TempSessionSections);
                raw_c_local = cell(mice_n, obj.NLearningSections, TempSessionSections);

                % ... for all mice within that type...
                for i = 1:mice_n
                    mouseID = mice{i};

                    % "Group" together trials into correct sections.
                    if split
                        session_matrix = obj.split_mouse_sessions_HMM(mouseID);
                    else
                        session_matrix = obj.split_mouse_sessions(mouseID);
                    end
                    % ... for each pair of learning section/session section ...
                    for j = 1:obj.NLearningSections
                        for k = 1:TempSessionSections
                            trial_cells = session_matrix{j, k};
                            [t, f, c, d] = deal(zeros(size(trial_cells)));

                            % ... for each "group" of trials in that given section.
                            % The "groups" of trials come from the split_mouse_sessions
                            % functions above.
                            for z = 1:length(trial_cells)
                                exp_trials = trial_cells{z};

                                [exp_t, exp_f, exp_d, exp_c] = ROC.roc_analysis_trials(exp_trials);

                                t(z) = exp_t;
                                f(z) = exp_f;
                                d(z) = exp_d;
                                c(z) = exp_c;
                            end

                            raw_t_local{i, j, k} = t;
                            raw_f_local{i, j, k} = f;
                            raw_d_local{i, j, k} = d;
                            raw_c_local{i, j, k} = c;
                        end
                    end
                end

                t_data(mouse_type) = raw_t_local;
                f_data(mouse_type) = raw_f_local;
                d_data(mouse_type) = raw_d_local;
                c_data(mouse_type) = raw_c_local;
            end

            if split
                [obj.TDataSplit, obj.FDataSplit, obj.DDataSplit, obj.CDataSplit] = deal(t_data, f_data, d_data, c_data);
            else
                [obj.TDataUnsplit, obj.FDataUnsplit, obj.DDataUnsplit, obj.CDataUnsplit] = deal(t_data, f_data, d_data, c_data);
            end
        end


        % ANALYSIS HELPERS - SPLITTING TRIALS
        function [ session_mat ] = split_mouse_sessions(obj, mouseID, format, varargin)
            %split_mouse_sessions Function used to split trials into NLearning X NSession sections
            %   Input  :: obj                   - object
            %             mouseID               - ID of mouse
            %             format                - specify whether each cell contains
            %                                       sessions or just all trials concatenated
            %                                       for that section; either 'Sessions'
            %                                       or 'Trials'; default is
            %                                       'Sessions'
            %           varargin::              - pass 'UseTraining' if being used to
            %                                        split in order to run HMM; in this case will use
            %                                        NTrainLearning and NTrainSession;
            %
            %   Output :: session_mat - num_learning_sections X
            %                                       num_session_sections matrix of trial data

            % Default Params
            if nargin < 3
                format = 'Sessions';
            end

            training_index = find(strcmp('UseTraining', varargin), 1);
            use_training = ~isempty(training_index);

            if use_training
                n_learning_sections = obj.NTrainLearningSections;
                n_session_sections = obj.NTrainSessionSections;
            else
                n_learning_sections = obj.NLearningSections;
                n_session_sections = obj.NSessionSections;
            end

            session_mat = cell(n_learning_sections, n_session_sections);
            [session_mat{:, :}] = deal({});

            mouse_sessions = lookup(obj.Sessions, 'mouseID', '=', mouseID, 'Order', 'sessionNumber', 'ASC', 'Fields', 'trialData', 'sessionNumber');
            learning_ranges = make_range(length(mouse_sessions), n_learning_sections);

            for i = 1:n_learning_sections
                range = learning_ranges{i};
                sessions_in_learning = mouse_sessions(range);

                for session = sessions_in_learning
                    try
                        trial_data = session.trialData;
                        num_trials = height(trial_data);
                    catch % No trials!!
                        warning(['No trials found for mouse' num2str(mouseID) ', learning section ' num2str(i) '/' num2str(n_learning_sections) ', session section ' num2str(session.sessionNumber) '/' num2str(n_session_sections)])
                        continue
                    end

                    trial_ranges = make_range(num_trials, n_session_sections);

                    for j = 1:n_session_sections
                        range = trial_ranges{j};
                        trials_in_section = trial_data(range, :);

                        % Formatting
                        if strcmp(format, 'Sessions')
                            session_mat{i, j} = [session_mat{i, j} {trials_in_section}];
                        elseif strcmp(format, 'Trials')
                            session_mat{i, j} = [session_mat{i, j}; trials_in_section];
                        else
                            error('Invalid format. Must be Sessions or Trials');
                        end
                    end
                end
            end

        end

        function [ session_mat ] = split_mouse_sessions_HMM(obj, mouseID)
            %split_mouse_sessions_HMM Function used to split trials into sections based
            %on engagement given by HMM analysis
            %
            %   Input  :: obj                   - object
            %             mouseID               - ID of mouse
            %
            %   Output :: session_mat - num_learning_sections X 1
            %                                matrix of engaged trial data

            session_mat = cell(obj.NLearningSections, 1);
            [session_mat{:, :}] = deal({});

            [E, ~] = obj.analyze_engagement(mouseID);

            for i = 1:obj.NLearningSections
                engaged_trials = E{i};

                try
                    num_trials = height(engaged_trials);
                catch % No Trials!!
                    warning(['No engaged trials found for mouse' num2str(mouseID) ', learning section ' num2str(i) '/' num2str(obj.NLearningSections)])
                    continue
                end

                num_pseudosessions = ceil(num_trials / obj.TrialsPerPseudoSession);

                pseudosessions = cell(1, num_pseudosessions);
                trial_ranges = make_range(num_trials, num_pseudosessions);

                for j = 1:num_pseudosessions
                    trial_range = trial_ranges{j};
                    pseudosessions{j} = engaged_trials(trial_range, :);
                end

                session_mat{i} = pseudosessions;
            end
        end


        % ANALYSIS HELPERS - ENGAGEMENT (HMM)
        function [e, n] = analyze_engagement(obj, mouseID)
            estimate_to_use = 1;  % there exists 2 estimates in current estimate file; have always used #1

            try
                load(obj.EstimatePath)
            catch
                generate_HMM_estimates
            end

            % Initialization for final ouput
            e = cell(obj.NTrainLearningSections, obj.NTrainSessionSections);
            n = cell(obj.NTrainLearningSections, obj.NTrainSessionSections);

            [e{:, :}] = deal(table);
            [n{:, :}] = deal(table);

            session_mat = obj.split_mouse_sessions(mouseID, 'Trials', 'UseTraining');  % must always be 3 x 3?

            for learning_section = 1:obj.NTrainLearningSections
                for session_section = 1:obj.NTrainSessionSections
                    section_trials = session_mat{learning_section, session_section};

                    set_T = estimate_T{learning_section, session_section}{obj.Tone}{estimate_to_use};
                    set_E = estimate_E{learning_section, session_section}{obj.Tone}{estimate_to_use};
                    [eTrials, nTrials] = obj.Trainer.train(section_trials, set_T, set_E, obj.Tone);

                    e{learning_section, session_section} = eTrials;
                    n{learning_section, session_section} = nTrials;
                end
            end

            e = obj.consolidate(e);
        end

        function [E] = consolidate(obj, E)
            % Combine all trials into one chronological table
            learning_section_tables = cell(obj.NTrainLearningSections, 1);
            [learning_section_tables{:}] = deal(table);

            for i = 1:obj.NTrainLearningSections
                for j = 1:obj.NTrainSessionSections
                    learning_section_tables{i} = [learning_section_tables{i}; E{i, j}];
                end
            end

            all_trials = table;
            for i = 1:obj.NTrainLearningSections
                all_trials = [all_trials; learning_section_tables{i}];
            end

            % Split all trials into NLearningSections sections; we ignore
            %   NSessionSections after splitting (b/c all sections ENGAGED)
            E = cell(obj.NLearningSections, 1);
            [E{:, :}] = deal(table);

            ranges = make_range(height(all_trials), obj.NLearningSections);

            for i = 1:obj.NLearningSections
                range = ranges{i};
                E{i} = all_trials(range, :);
            end
        end


        % OTHER
        function filename = default_filename(obj)
            filename = ['roc_data_' num2str(obj.NLearningSections) '_' num2str(obj.NSessionSections) '_' obj.TaskType '-' ROC.hashTWDB(obj.TWDB)];
        end
    end

    methods (Static = true, Access = public)
        % CONVENIENCE FOR ALL ANALYSES
        function run_all(twdb)
            disp('Running NLearning = 1, NSession = 1')
            r = ROC(twdb, 1, 1, 'tt', 'ForceGenerate', 'IgnoreSplit');
            r.save();

            disp('Running NLearning = 3, NSession = 1')
            r = ROC(twdb, 3, 1, 'tt', 'ForceGenerate');
            r.save();

            disp('Running NLearning = 3, NSession = 3')
            r = ROC(twdb, 3, 3, 'tt', 'ForceGenerate');
            r.save();
        end

        % ROC ANALYSES
        function [t, f, d, c] = roc_analysis_trials(trials)
            [raw_t, raw_f] = roc_helper_trials(trials);

            % Clip values as to not distort d-prime and c (TPR/FPR values of 1 or 0
            % correspond to undefined values for norminv function)
            clip_max = @(x) min([x 0.99]);
            clip_min = @(x) max([x 0.01]);
            clip = @(x) clip_max(clip_min(x));

            clipt = clip(raw_t);
            clipf = clip(raw_f);

            z_h = norminv(clipt);
            z_f = norminv(clipf);

            % Place Data
            t = clipt;
            f = clipf;
            d = z_h - z_f;
            c = -0.5 * (z_h + z_f);


            function [tpr, fpr] = roc_helper_trials( trials )
                %ROC_HELPER_TRIALS Helper function to run ROC analysis for trials
                %   Evaluate the true-positive rate, false-positive rate, d-prime, and c
                %   values for any number of sessions. TPR and FPR will NOT be clipped.
                %
                %   Input  :: trials   - table of trial data
                %
                %   Output :: tpr      - true positive rate of trials
                %             fpr      - false positive rate of trials

                positive_stim = 1;
                negative_stim = 2;
                lick_threshold = 1;

                num_hits = 0;
                num_pos_trials = 0;

                num_false_alarm = 0;
                num_neg_trials = 0;

                % Check to see if trials are empty
                if isempty(trials)
                    [tpr, fpr] = deal(NaN);
                    warning('No Trial Data! Using NaN values instead');
                    return
                end

                for i = 1:height(trials)
                    trial = trials(i, :);

                    % Check for True Positive
                    if trial.StimulusID == positive_stim
                        num_pos_trials = num_pos_trials + 1;

                        if trial.ResponseLickFrequency >= lick_threshold
                            num_hits = num_hits + 1;
                        end
                    end

                    % Check for False Positive
                    if trial.StimulusID == negative_stim
                        num_neg_trials = num_neg_trials + 1;

                        if trial.ResponseLickFrequency >= lick_threshold
                            num_false_alarm = num_false_alarm + 1;
                        end
                    end
                end

                tpr = num_hits / num_pos_trials;
                fpr = num_false_alarm / num_neg_trials;
            end
        end

        function [t, f, d, c] = roc_analysis_sessions(sessions, n_session_sections)
            %ROC_ANALYSIS_SESSIONS Run ROC analysis for any amount of sessions
            %   Evaluate the true-positive rate, false-positive rate, d-prime, and c
            %   values for any number of sessions. Note: TPR and FPR values will be
            %   clipped at 0.01 and 0.99.
            %
            %   Input  :: sessions - 1 x num_sessions cell array of two-tone sessions to analyze
            %
            %   Output :: t   -  num_sessions-length vector of true-positive rates, where tpr(i)
            %                    corresponds to the TPR of the session in sessions(i)
            %             f   -  num_sessions=length vector of false-positive rates, where fpr(i)
            %                    corresponds to the FPR of the session in sessions(i)
            %             d   -  num_sessions-length vector of d-primes, where dp(i)
            %                    corresponds to the d-prime of the session in sessions(i)
            %             c   -  num_sessions-length vector of c's, where c(i)
            %                    corresponds to the c of the session in sessions(i)

            num_sessions = length(sessions);

            % Arrays to store computed data
            t = zeros(1, num_sessions);                   % One TPR value for each session
            f = zeros(1, num_sessions);                   % One FPR value for each session
            d = zeros(1, num_sessions);                   % One d' value for each session
            c = zeros(1, num_sessions);                   % One c value for each session

            % Get data for each session
            for i = 1:num_sessions
                sesh = sessions(i);

                % Get TPR, FPR from helper
                [tpr, fpr] = ROC.roc_analysis_trials(sesh.trialData);

                z_h = norminv(tpr);
                z_f = norminv(fpr);

                % Place Data
                t(i) = tpr;
                f(i) = fpr;
                d(i) = z_h - z_f;
                c(i) = -0.5 * (z_h + z_f);
            end
        end
    end

    methods (Static = true, Access = private)
        % CLASS SERVICES
        function hash = hashTWDB(twdb)
            firstSession = twdb(1);
            firstHash = firstSession.mouseID;

            midSession = twdb(round(length(twdb) / 2, 0));
            midHash = midSession.sessionNumber;

            lastSession = twdb(end);
            lastHash = height(lastSession.trialData);

            nonce = length(twdb);

            hash = [num2str(firstHash) num2str(midHash) num2str(lastHash) num2str(nonce)];
        end

        function [mice, n] = get_mice( health, task_type )
            %GET_MICE Get IDs of mice of specific health and task type
            %
            %   Input  :: health    -  health type of mice
            %             task_type -  task type
            %
            %   Output :: mice      -  1 x n cell array of mouse IDs
            %             n         -  number of mice

            % 2831 DIED, 2703 & 2705 different age (> 13 months)

            % Two Tone
            WT_mice_tt = {'2736', '2739', '2741', '2743', '2776', '2781', '2782', '2802'};
            HD_mice_tt = {'2777', '2785', '2786', '2789', '2790', '2852'}; %'2833','2834'

            % Two Tone Reversal
            WT_mice_2tr = {'2736', '2739', '2741', '2743', '2776', '2781', '2782', '2802'};
            HD_mice_2tr = {'2777', '2785', '2786', '2789', '2790', '2852'}; %'2833','2834'

            switch [health task_type]
                case 'WTtt'
                    mice = WT_mice_tt;
                case 'HDtt'
                    mice = HD_mice_tt;
                case 'WT2tr'
                    mice = WT_mice_2tr;
                case 'HD2tr'
                    mice = HD_mice_2tr;
                otherwise
                    error('Invalid mouse health and/or task type');
            end

            n = length(mice);
        end
    end
end
